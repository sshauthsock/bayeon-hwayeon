# .github/workflows/deploy.yml
# This workflow is for deploying the frontend (SPA) to GitHub Pages.

name: Deploy Frontend & Backend # 워크플로우 이름

on:
  push:
    branches:
      - main # <<-- 여러분의 기본 브랜치 (main 또는 master)에 맞춰 설정

jobs:
  deploy-frontend: # 작업 이름 (프론트엔드 전용)
    runs-on: ubuntu-latest # GitHub Actions는 Ubuntu 가상 환경에서 실행

    # GitHub Actions 워크플로우 자체의 권한 설정
    # 이 권한은 GitHub Pages 배포에만 필요합니다.
    permissions:
      contents: write # 저장소 콘텐츠(gh-pages 브랜치)에 쓰기 권한
      pages: write # GitHub Pages 배포를 위한 권한
      id-token: write # GitHub Pages v3 액션의 OIDC 관련 (현재 JamesIves 액션에는 불필요할 수 있으나 안전을 위해 유지)

    # 환경 변수 설정 (GCP 관련 환경 변수는 이제 필요 없음)
    # env:
    # 이 워크플로우는 GCP와 직접 통신하지 않으므로 GCP_PROJECT_ID, AR_LOCATION 등은 필요 없습니다.
    # 백엔드 배포 워크플로우에서 별도로 관리됩니다.
    # 예시:
    # GCP_PROJECT_ID: your-gcp-project-id
    # AR_LOCATION: asia-northeast3
    # AR_REPO_NAME: go-backend-repo
    # CR_SERVICE_NAME: wind-app-backend
    # CR_SERVICE_ACCOUNT: your-cloud-run-service-account@your-project-id.iam.gserviceaccount.com

    steps:
      - name: Checkout repository # GitHub 저장소 코드를 가상 머신으로 가져옵니다.
        uses: actions/checkout@v3

      - name: Setup Node.js (for JS/CSS processing) # 프론트엔드 빌드 도구인 Node.js 설정
        uses: actions/setup-node@v3
        with:
          node-version: "16" # 여러분의 Node.js 버전에 맞춰 조정

      - name: Install JavaScript/CSS tools # JS/CSS 난독화/압축 도구 설치
        run: |
          npm install -g javascript-obfuscator
          npm install -g clean-css-cli

      # -------------------------------------------------------------
      # 1. Frontend Processing (Obfuscation, Minification, Cache Busting)
      #    이 섹션은 프론트엔드 파일을 처리하여 배포 준비를 합니다.
      #    이 저장소는 프론트엔드만 포함하고 있다고 가정합니다.
      # -------------------------------------------------------------
      - name: Create dist directory and copy files # 배포할 파일들을 모을 dist 폴더 생성 및 복사
        run: |
          rm -rf dist # 기존 dist 폴더 삭제
          mkdir -p dist # 새 dist 폴더 생성

          # rsync를 사용하여 .git/, node_modules/, .env, .github/ 등 불필요한 파일을 제외하고 루트의 모든 파일과 폴더를 dist로 복사
          # 'backend/'는 이 프론트엔드 전용 저장소에는 없어야 하지만, 혹시라도 있다면 제외합니다.
          rsync -av --exclude='.git/' --exclude='dist/' --exclude='node_modules/' --exclude='.env' --exclude='.github/' . dist/ || true

          # [수정 시작] update-html.js 파일을 dist 폴더로 복사하고 이름을 변경
          # update-html.js 파일은 프로젝트 루트에 있다고 가정합니다.
          # 워크플로우에서 참조하는 이름과 일치시킵니다.
          cp update-html.js dist/update_html_references.js
          # [수정 끝]

          # 숨김 파일 중 .nojekyll을 제외하고 삭제 (GitHub Pages에서 필요할 수 있음)
          find dist -type f -name ".*" ! -name ".nojekyll" -delete || true

      - name: Process JS files (Obfuscate and rename) # JavaScript 파일 난독화 및 이름 변경
        run: |
          timestamp=$(date +%s) # 현재 타임스탬프를 가져와 파일명에 사용
          echo "# JS file mapping" > js_mapping.txt # JS 파일 매핑 정보를 저장할 파일 생성

          # dist/js/ 안에 있는 모든 JS 파일을 찾습니다. (예: dist/js/main.js)
          # 여러분의 프로젝트 구조에 맞춰 정확한 경로를 확인해주세요.
          find dist/js -type f -name "*.js" | while read file; do
            echo "Processing JS: $file"
            dir_path=$(dirname "$file")
            base_name=$(basename "$file" .js)
            new_file="${dir_path}/${base_name}.obf.${timestamp}.js" # 새 파일명 생성 (obf.타임스탬프.js)
            
            # javascript-obfuscator 도구로 난독화
            javascript-obfuscator "$file" --output "$new_file" \
              --compact true \
              --control-flow-flattening true \
              --dead-code-injection true \
              --string-array true \
              --self-defending true
            
            if [ -f "$new_file" ]; then # 난독화된 파일이 성공적으로 생성되면
              orig_size=$(wc -c < "$file")
              new_size=$(wc -c < "$new_file")
              echo "  ✅ ${file}: ${orig_size} → ${new_size} bytes"
              
              orig_relative=${file#dist/} # dist/ 기준 상대 경로 (예: js/main.js)
              new_relative=${new_file#dist/} # (예: js/main.obf.1234.js)
              echo "$orig_relative,$new_relative" >> js_mapping.txt # 매핑 정보 기록
              rm "$file" # 원본 JS 파일 삭제
            else
              echo "  ❌ Failed to obfuscate: $file"
              exit 1 # 난독화 실패 시 워크플로우 중단
            fi
          done
          echo "=== JS FILE MAPPING ==="
          cat js_mapping.txt || true # 매핑 파일 내용 출력
          echo "======================="

      - name: Process CSS files (Minify and rename) # CSS 파일 압축 및 이름 변경
        run: |
          timestamp=$(date +%s)
          echo "# CSS file mapping" > css_mapping.txt

          # dist/assets/css/ 안에 있는 모든 CSS 파일을 찾습니다. (예: dist/assets/css/main.css)
          # 여러분의 프로젝트 구조에 맞춰 정확한 경로를 확인해주세요.
          find dist/assets/css -type f -name "*.css" | while read file; do
            echo "Processing CSS: $file"
            dir_path=$(dirname "$file")
            base_name=$(basename "$file" .css)
            new_file="${dir_path}/${base_name}.min.${timestamp}.css" # 새 파일명 생성 (min.타임스탬프.css)
            
            # cleancss 도구로 압축
            cleancss -o "$new_file" "$file"
            
            if [ -f "$new_file" ]; then # 압축된 파일이 성공적으로 생성되면
              orig_size=$(wc -c < "$file")
              new_size=$(wc -c < "$new_file")
              echo "  ✅ ${file}: ${orig_size} → ${new_size} bytes"
              
              orig_relative=${file#dist/}
              new_relative=${new_file#dist/}
              echo "$orig_relative,$new_relative" >> css_mapping.txt
              rm "$file" # 원본 CSS 파일 삭제
            else
              echo "  ❌ Failed to minify: $file"
              exit 1 # 압축 실패 시 워크플로우 중단
            fi
          done
          echo "=== CSS FILE MAPPING ==="
          cat css_mapping.txt || true
          echo "======================="

      - name: Update HTML files to use processed JS and CSS # HTML 파일 내 JS/CSS 참조 경로 업데이트
        # Node.js 스크립트 실행 (./로 현재 디렉토리 명시)
        run: |
          # update_html_references.js 파일은 Create dist directory and copy files 스텝에서 dist/로 복사되었습니다.
          node ./update_html_references.js

          # 최종적으로 dist/index.html 파일의 내용을 확인하는 디버깅 스텝
          echo "===== Final dist/index.html content after updates ====="
          cat dist/index.html | head -n 30 # 상위 30줄만 출력하여 확인
          echo "======================================================="
        working-directory: ./dist/ # 이 스텝의 작업 디렉토리를 dist/ 로 설정합니다.

      - name: Prepare index.html for GitHub Pages (if needed) # index.html 진입점 확인/설정
        run: |
          echo "Ensuring index.html is the entry point for SPA. No special redirect needed."

      # -------------------------------------------------------------
      # 2. Deploy Frontend to GitHub Pages
      #    처리된 프론트엔드 파일들을 GitHub Pages로 배포합니다.
      # -------------------------------------------------------------
      - name: Deploy Frontend to GitHub Pages
        uses: JamesIves/github-pages-deploy-action@v4
        with:
          branch: gh-pages # 배포할 브랜치 (gh-pages 브랜치가 없으면 자동으로 생성됨)
          folder: dist # 배포할 소스 코드 폴더 (처리된 파일들이 있는 곳)
          clean: true # gh-pages 브랜치의 이전 내용을 정리하고 배포
          token: ${{ secrets.GITHUB_TOKEN }} # GitHub Pages 배포 권한을 가진 토큰 (GitHub Actions가 자동으로 제공)


      # -------------------------------------------------------------
      # 백엔드 배포 관련 스텝들은 모두 제거됨 (프론트엔드 전용 워크플로우)
      # -------------------------------------------------------------
