# .github/workflows/deploy.yml
# This workflow is for deploying the frontend (SPA) to GitHub Pages.

name: Deploy Frontend to GitHub Pages # 워크플로우 이름 (프론트엔드 전용)

on:
  push:
    branches:
      - main # <<-- 여러분의 기본 브랜치 (main 또는 master)에 맞춰 설정

jobs:
  deploy-frontend: # 작업 이름 (프론트엔드 전용)
    runs-on: ubuntu-latest # GitHub Actions는 Ubuntu 가상 환경에서 실행

    # GitHub Actions 워크플로우 자체의 권한 설정
    # 이 권한은 GitHub Pages 배포에만 필요합니다.
    permissions:
      contents: write # 저장소 콘텐츠(gh-pages 브랜치)에 쓰기 권한
      pages: write # GitHub Pages 배포를 위한 권한
      # id-token: write # Google Cloud 인증이 없어지므로 더 이상 필요 없음. (제거 또는 주석 처리)

    # 환경 변수 설정 (GCP 관련 환경 변수는 이제 필요 없음)
    # env:
    # GCP_PROJECT_ID:
    # AR_LOCATION:
    # AR_REPO_NAME:
    # CR_SERVICE_NAME:
    # CR_SERVICE_ACCOUNT:

    steps:
      - name: Checkout repository # GitHub 저장소 코드를 가상 머신으로 가져옵니다.
        uses: actions/checkout@v3

      - name: Setup Node.js (for JS/CSS processing) # 프론트엔드 빌드 도구인 Node.js 설정
        uses: actions/setup-node@v3
        with:
          node-version: "16" # 여러분의 Node.js 버전에 맞춰 조정

      - name: Install JavaScript/CSS tools # JS/CSS 난독화/압축 도구 설치
        run: |
          npm install -g javascript-obfuscator
          npm install -g clean-css-cli

      # -------------------------------------------------------------
      # 1. Frontend Processing (Obfuscation, Minification, Cache Busting)
      #    이 섹션은 프론트엔드 파일을 처리하여 배포 준비를 합니다.
      #    이 저장소는 프론트엔드만 포함하고 있다고 가정합니다.
      # -------------------------------------------------------------
      - name: Create dist directory and copy files
        run: |
          rm -rf dist
          mkdir -p dist

          # [수정 시작] rsync 사용으로 복사 로직 통합 및 명확화
          # 현재 디렉토리(저장소 루트)의 모든 파일과 폴더를 dist/ 로 복사
          # 특정 폴더들은 제외 (Git 관련, 빌드 결과물, 설정 파일)
          rsync -av --exclude='.git/' --exclude='dist/' --exclude='node_modules/' --exclude='.env' --exclude='.github/' --exclude='backend/' . dist/ || true

          # 숨김 파일 중 .nojekyll을 제외하고 삭제
          find dist -type f -name ".*" ! -name ".nojekyll" -delete || true

      - name: Process JS files (Obfuscate and rename) # JavaScript 파일 난독화 및 이름 변경
        run: |
          timestamp=$(date +%s) # 현재 타임스탬프를 가져와 파일명에 사용
          echo "# JS file mapping" > js_mapping.txt # JS 파일 매핑 정보를 저장할 파일 생성

          # dist/js/ 안에 있는 모든 JS 파일을 찾습니다. (예: dist/js/main.js)
          # 여러분의 프로젝트 구조에 맞춰 정확한 경로를 확인해주세요.
          find dist/js -type f -name "*.js" | while read file; do
            echo "Processing JS: $file"
            dir_path=$(dirname "$file")
            base_name=$(basename "$file" .js)
            new_file="${dir_path}/${base_name}.obf.${timestamp}.js" # 새 파일명 생성 (obf.타임스탬프.js)
            
            # javascript-obfuscator 도구로 난독화
            javascript-obfuscator "$file" --output "$new_file" \
              --compact true \
              --control-flow-flattening true \
              --dead-code-injection true \
              --string-array true \
              --self-defending true
            
            if [ -f "$new_file" ]; then # 난독화된 파일이 성공적으로 생성되면
              orig_size=$(wc -c < "$file")
              new_size=$(wc -c < "$new_file")
              echo "  ✅ ${file}: ${orig_size} → ${new_size} bytes"
              
              orig_relative=${file#dist/} # dist/ 기준 상대 경로 (예: js/main.js)
              new_relative=${new_file#dist/} # (예: js/main.obf.1234.js)
              echo "$orig_relative,$new_relative" >> js_mapping.txt # 매핑 정보 기록
              rm "$file" # 원본 JS 파일 삭제
            else
              echo "  ❌ Failed to obfuscate: $file"
              exit 1 # 난독화 실패 시 워크플로우 중단
            fi
          done
          echo "=== JS FILE MAPPING ==="
          cat js_mapping.txt || true # 매핑 파일 내용 출력
          echo "======================="

      - name: Process CSS files (Minify and rename) # CSS 파일 압축 및 이름 변경
        run: |
          timestamp=$(date +%s)
          echo "# CSS file mapping" > css_mapping.txt

          # dist/assets/css/ 안에 있는 모든 CSS 파일을 찾습니다. (예: dist/assets/css/main.css)
          # 여러분의 프로젝트 구조에 맞춰 정확한 경로를 확인해주세요.
          find dist/assets/css -type f -name "*.css" | while read file; do
            echo "Processing CSS: $file"
            dir_path=$(dirname "$file")
            base_name=$(basename "$file" .css)
            new_file="${dir_path}/${base_name}.min.${timestamp}.css" # 새 파일명 생성 (min.타임스탬프.css)
            
            # cleancss 도구로 압축
            cleancss -o "$new_file" "$file"
            
            if [ -f "$new_file" ]; then # 압축된 파일이 성공적으로 생성되면
              orig_size=$(wc -c < "$file")
              new_size=$(wc -c < "$new_file")
              echo "  ✅ ${file}: ${orig_size} → ${new_size} bytes"
              
              orig_relative=${file#dist/}
              new_relative=${new_file#dist/}
              echo "$orig_relative,$new_relative" >> css_mapping.txt
              rm "$file" # 원본 CSS 파일 삭제
            else
              echo "  ❌ Failed to minify: $file"
              exit 1 # 압축 실패 시 워크플로우 중단
            fi
          done
          echo "=== CSS FILE MAPPING ==="
          cat css_mapping.txt || true
          echo "======================="

      - name: Update HTML files to use processed JS and CSS # HTML 파일 내 JS/CSS 참조 경로 업데이트
        run:
          | # [수정 시작] YAML 리터럴 블록 (|)을 사용하여 Node.js 스크립트를 안전하게 포함
          # 임시 Node.js 스크립트 파일 생성
          cat << 'EOF' > update_html_references.js
          const fs = require('fs');
          const path = require('path');
                
          const htmlFilesDir = './dist'; // HTML 파일들이 있는 디렉토리 (dist/)
                
          // 매핑 파일 읽기 헬퍼 함수
          function readMappingFile(filePath) {
              if (!fs.existsSync(filePath)) {
                  return new Map();
              }
              const content = fs.readFileSync(filePath, 'utf8');
              const lines = content.split('\n').filter(line => line.trim() !== '' && !line.startsWith('#'));
              const mapping = new Map();
              lines.forEach(line => {
                  const [oldPath, newPath] = line.split(',');
                  if (oldPath && newPath) {
                      mapping.set(oldPath.trim(), newPath.trim());
                  }
              });
              return mapping;
          }
                
          const jsMapping = readMappingFile('js_mapping.txt');
          const cssMapping = readMappingFile('css_mapping.txt');
                
          console.log('JS MAPPING:', jsMapping);
          console.log('CSS MAPPING:', cssMapping);
                
          // HTML 파일들을 재귀적으로 찾기
          function findHtmlFiles(dir) {
              let htmlFiles = [];
              const files = fs.readdirSync(dir);
              for (const file of files) {
                  const fullPath = path.join(dir, file);
                  const stat = fs.statSync(fullPath);
                  if (stat.isDirectory()) {
                      htmlFiles = htmlFiles.concat(findHtmlFiles(fullPath));
                  } else if (stat.isFile() && file.endsWith('.html')) {
                      htmlFiles.push(fullPath);
                  }
              }
              return htmlFiles;
          }
            
          const htmlFiles = findHtmlFiles(htmlFilesDir);
            
          htmlFiles.forEach(htmlFilePath => {
              console.log(`Updating references in: ${htmlFilePath}`);
              let content = fs.readFileSync(htmlFilePath, 'utf8');
            
              jsMapping.forEach((newPath, oldPath) => {
                  const escapedOldPath = oldPath.replace(/[.*+?^${}()|[$$$$/g, '\\$&');
                  // 정규식 패턴: src="oldPath" 또는 src='oldPath' 또는 src="/oldPath" 또는 src='/oldPath'
                  // 여기서 " 와 ' 를 포함하는 정규식을 사용할 때는 백틱(`)을 사용하거나 따옴표를 명확히 해야 합니다.
                  // Node.js String.prototype.replace는 백레퍼런스 ($1) 대신 $1을 써야 함
                  const regex = new RegExp(`src=["']\\/?${escapedOldPath}["']`, 'g');
                  content = content.replace(regex, `src="${newPath}"`);
                  console.log(`  JS: Replaced src ${oldPath} with ${newPath}`);
              });
            
              cssMapping.forEach((newPath, oldPath) => {
                  const escapedOldPath = oldPath.replace(/[.*+?^${}()|[$$$$/g, '\\$&');
                  const regex = new RegExp(`href=["']\\/?${escapedOldPath}["']`, 'g');
                  content = content.replace(regex, `href="${newPath}"`);
                  console.log(`  CSS: Replaced href ${oldPath} with ${newPath}`);
              });
            
              const timestamp = new Date().toLocaleString();
              content = `<!-- Files processed: ${timestamp} -->\n` + content;
            
              fs.writeFileSync(htmlFilePath, content, 'utf8');
              console.log(`Updated references in ${htmlFilePath}`);
          EOF
          # 생성된 Node.js 스크립트 실행
          node update_html_references.js
          # [수정 끝]

          echo "===== Final dist/index.html content after updates ====="
          cat dist/index.html | head -n 30
          echo "======================================================="
      - name: Prepare index.html for GitHub Pages (if needed) # index.html 진입점 확인/설정
        run: |
          echo "Ensuring index.html is the entry point for SPA. No special redirect needed."

      # -------------------------------------------------------------
      # 2. Deploy Frontend to GitHub Pages
      #    처리된 프론트엔드 파일들을 GitHub Pages로 배포합니다.
      # -------------------------------------------------------------
      - name: Deploy Frontend to GitHub Pages
        uses: JamesIves/github-pages-deploy-action@v4
        with:
          branch: gh-pages # 배포할 브랜치 (gh-pages 브랜치가 없으면 자동으로 생성됨)
          folder: dist # 배포할 소스 코드 폴더 (처리된 파일들이 있는 곳)
          clean: true # gh-pages 브랜치의 이전 내용을 정리하고 배포
          token: ${{ secrets.GITHUB_TOKEN }} # GitHub Pages 배포 권한을 가진 토큰 (GitHub Actions가 자동으로 제공)


      # -------------------------------------------------------------
      # 백엔드 배포 관련 스텝들은 모두 제거됨 (프론트엔드 전용 워크플로우)
      # -------------------------------------------------------------
